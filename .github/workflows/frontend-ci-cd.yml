name: frontend-pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - '.github/workflows/frontend-ci-cd.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - '.github/workflows/frontend-ci-cd.yml'

env:
  NODE_VERSION: '18'
  AWS_REGION: us-east-1
  ECR_REPOSITORY: customer-frontend
  FRONTEND_HELM_CHART_PATH: infrastructure/charts/customer-frontend
  DEV_CLUSTER_NAME: tcc-ufu-dev-cluster
  PROD_CLUSTER_NAME: tcc-ufu-prod-cluster

jobs:
  # Job 1: Build and Test Frontend
  build-and-test:
    name: Build and Test Frontend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-deploy: ${{ steps.check-deploy.outputs.should-deploy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: make install

    - name: Lint code
      run: make lint

    - name: Run unit tests
      run: make test

    - name: Build application
      run: make build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

    - name: Generate version
      id: version
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          VERSION="v$(date +%Y%m%d)-${GITHUB_SHA::7}"
        else
          VERSION="v$(date +%Y%m%d)-${GITHUB_SHA::7}-dev"
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "Generated version: ${VERSION}"

    - name: Check if should deploy
      id: check-deploy
      run: |
        if [[ "${{ github.event_name }}" == "push" ]] && [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  # Job 2: Build and Push Docker Image
  build-and-push:
    name: Build and Push Frontend Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.should-deploy == 'true'
    defaults:
      run:
        working-directory: ./frontend
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.build-and-test.outputs.version }}
      run: |
        # Build Docker image with API URL
        docker build \
          --build-arg REACT_APP_API_URL="/api" \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build \
          --build-arg REACT_APP_API_URL="/api" \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output image URI
        IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "Pushed image: $IMAGE_URI"

  # Job 3: Deploy to Dev Environment
  deploy-dev:
    name: Deploy Frontend to Dev Environment
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push]
    if: needs.build-and-test.outputs.should-deploy == 'true'
    environment: development
    
    outputs:
      dev-url: ${{ steps.deploy.outputs.url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install and configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.DEV_CLUSTER_NAME }}

    - name: Deploy Frontend to Dev with Helm
      id: deploy
      env:
        IMAGE_URI: ${{ needs.build-and-push.outputs.image-uri }}
        VERSION: ${{ needs.build-and-test.outputs.version }}
      run: |
        # Create namespace with Istio Ambient Mode label
        kubectl create namespace development --dry-run=client -o yaml | \
          kubectl label --local -f - istio.io/dataplane-mode=ambient -o yaml | \
          kubectl apply -f -
        
        # Helm upgrade/install
        helm upgrade --install customer-frontend-dev ${{ env.FRONTEND_HELM_CHART_PATH }} \
          --namespace development \
          --set image.repository=$(echo $IMAGE_URI | cut -d':' -f1) \
          --set image.tag=$VERSION \
          --wait \
          --timeout=300s

        # Get the Istio Gateway URL
        echo "Waiting for Istio Gateway to be ready..."
        sleep 30
        
        GATEWAY_URL=$(kubectl get svc -n istio-ingress istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        if [ -n "$GATEWAY_URL" ]; then
          DEV_URL="http://$GATEWAY_URL"
          echo "url=$DEV_URL" >> $GITHUB_OUTPUT
          echo "Dev deployment URL: $DEV_URL"
        else
          echo "Gateway URL not available yet"
          echo "url=" >> $GITHUB_OUTPUT
        fi

    - name: Verify deployment
      run: |
        kubectl get pods -n development -l app.kubernetes.io/name=customer-frontend
        kubectl get svc -n development -l app.kubernetes.io/name=customer-frontend

  # Job 4: Run E2E Tests against Dev
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    defaults:
      run:
        working-directory: ./integration_test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: integration_test/package-lock.json

    - name: Install dependencies
      run: make install

    - name: Install Playwright browsers
      run: make install-browsers

    - name: Configure AWS credentials for kubectl
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install and configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.DEV_CLUSTER_NAME }}

    - name: Wait for dev environment to be ready
      run: |
        DEV_URL="${{ needs.deploy-dev.outputs.dev-url }}"
        if [ -n "$DEV_URL" ]; then
          echo "Testing dev environment at: $DEV_URL"
          
          # Wait for service to be healthy (up to 5 minutes)
          for i in {1..30}; do
            if curl -f "$DEV_URL/" > /dev/null 2>&1; then
              echo "Dev environment is ready!"
              break
            fi
            echo "Waiting for dev environment... ($i/30)"
            sleep 10
          done
        else
          echo "Dev URL not available, using kubectl port-forward"
        fi

    - name: Run E2E tests against dev environment
      env:
        FRONTEND_BASE_URL: ${{ needs.deploy-dev.outputs.dev-url || 'http://localhost:3000' }}
        API_BASE_URL: ${{ needs.deploy-dev.outputs.dev-url || 'http://localhost:8080' }}
        CI: true
      run: |
        if [ -z "${{ needs.deploy-dev.outputs.dev-url }}" ]; then
          # Port forward if Gateway URL not available
          kubectl port-forward -n istio-ingress svc/istio-ingressgateway 3000:80 &
          PORT_FORWARD_PID=$!
          sleep 10
          export FRONTEND_BASE_URL="http://localhost:3000"
        fi
        
        # Run the frontend tests (no prereq checks in CI)
        make test-frontend-ci || TEST_RESULT=$?
        
        # Cleanup port forward if used
        if [ -n "$PORT_FORWARD_PID" ]; then
          kill $PORT_FORWARD_PID 2>/dev/null || true
        fi
        
        # Exit with test result
        exit ${TEST_RESULT:-0}

    - name: Upload E2E test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: e2e-test-results-frontend
        path: |
          integration_test/playwright-report/
          integration_test/test-results/

  # Job 5: Promote Image to Production ECR
  promote-image:
    name: Promote Image to Production ECR
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push, e2e-tests]
    if: github.ref == 'refs/heads/main' && needs.build-and-test.outputs.should-deploy == 'true' && needs.e2e-tests.result == 'success'
    
    outputs:
      prod-image-uri: ${{ steps.promote.outputs.prod-image }}

    steps:
    - name: Configure AWS credentials for Dev ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Dev Amazon ECR
      id: login-dev-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Configure AWS credentials for Prod ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.PROD_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Prod Amazon ECR
      id: login-prod-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Promote image from Dev to Prod ECR
      id: promote
      env:
        DEV_ECR_REGISTRY: ${{ steps.login-dev-ecr.outputs.registry }}
        PROD_ECR_REGISTRY: ${{ steps.login-prod-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.build-and-test.outputs.version }}
      run: |
        # Pull image from dev ECR
        DEV_IMAGE_URI=$DEV_ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        PROD_IMAGE_URI=$PROD_ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        PROD_LATEST_URI=$PROD_ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "Pulling image from dev ECR: $DEV_IMAGE_URI"
        docker pull $DEV_IMAGE_URI
        
        # Re-tag for production ECR
        docker tag $DEV_IMAGE_URI $PROD_IMAGE_URI
        docker tag $DEV_IMAGE_URI $PROD_LATEST_URI
        
        # Push to production ECR
        echo "Pushing image to prod ECR: $PROD_IMAGE_URI"
        docker push $PROD_IMAGE_URI
        docker push $PROD_LATEST_URI
        
        # Output production image URI
        echo "prod-image=$PROD_IMAGE_URI" >> $GITHUB_OUTPUT
        echo "Successfully promoted image to production ECR: $PROD_IMAGE_URI"

  # Job 6: Deploy to Production
  deploy-prod:
    name: Deploy Frontend to Production
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push, e2e-tests, promote-image]
    if: github.ref == 'refs/heads/main' && needs.build-and-test.outputs.should-deploy == 'true'
    environment: 
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.PROD_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install and configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.PROD_CLUSTER_NAME }}

    - name: Deploy Frontend to Production with Helm
      id: deploy
      env:
        IMAGE_URI: ${{ needs.promote-image.outputs.prod-image-uri }}
        VERSION: ${{ needs.build-and-test.outputs.version }}
      run: |
        # Create namespace with Istio Ambient Mode label
        kubectl create namespace production --dry-run=client -o yaml | \
          kubectl label --local -f - istio.io/dataplane-mode=ambient -o yaml | \
          kubectl apply -f -
        
        # Helm upgrade/install to production
        helm upgrade --install customer-frontend-prod ${{ env.FRONTEND_HELM_CHART_PATH }} \
          --namespace production \
          --set image.repository=$(echo $IMAGE_URI | cut -d':' -f1) \
          --set image.tag=$VERSION \
          --set replicaCount=3 \
          --set resources.requests.cpu="50m" \
          --set resources.requests.memory="64Mi" \
          --set resources.limits.cpu="200m" \
          --set resources.limits.memory="256Mi" \
          --wait \
          --timeout=600s

        # Get the production Gateway URL
        echo "Waiting for production Gateway to be ready..."
        sleep 30
        
        GATEWAY_URL=$(kubectl get svc -n istio-ingress istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        if [ -n "$GATEWAY_URL" ]; then
          PROD_URL="http://$GATEWAY_URL"
          echo "url=$PROD_URL" >> $GITHUB_OUTPUT
          echo "Production deployment URL: $PROD_URL"
        else
          echo "Production Gateway URL not available yet"
          echo "url=" >> $GITHUB_OUTPUT
        fi

    - name: Verify production deployment
      run: |
        kubectl get pods -n production -l app.kubernetes.io/name=customer-frontend
        kubectl get svc -n production -l app.kubernetes.io/name=customer-frontend

    - name: Run production smoke tests
      if: steps.deploy.outputs.url != ''
      run: |
        PROD_URL="${{ steps.deploy.outputs.url }}"
        echo "Running smoke tests against: $PROD_URL"
        
        # Basic health check
        for i in {1..10}; do
          if curl -f "$PROD_URL/" > /dev/null 2>&1; then
            echo "âœ… Production health check passed"
            break
          fi
          echo "Waiting for production to be healthy... ($i/10)"
          sleep 30
        done

  # Job 7: Notify and Clean up
  notify:
    name: Notify Frontend Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push, deploy-dev, e2e-tests, promote-image, deploy-prod]
    if: always() && needs.build-and-test.outputs.should-deploy == 'true'
    
    steps:
    - name: Determine deployment status
      id: status
      run: |
        if [[ "${{ needs.e2e-tests.result }}" == "failure" ]]; then
          echo "status=âŒ E2E Tests Failed" >> $GITHUB_OUTPUT
          echo "color=danger" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.deploy-prod.result }}" == "success" ]]; then
          echo "status=âœ… Deployed to Production" >> $GITHUB_OUTPUT
          echo "color=success" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.deploy-dev.result }}" == "success" ]]; then
          echo "status=ðŸš€ Deployed to Development" >> $GITHUB_OUTPUT
          echo "color=warning" >> $GITHUB_OUTPUT
        else
          echo "status=âŒ Deployment Failed" >> $GITHUB_OUTPUT
          echo "color=danger" >> $GITHUB_OUTPUT
        fi

    - name: Create deployment summary
      run: |
        echo "## ðŸŽ¨ Frontend Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ needs.build-and-test.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Results" >> $GITHUB_STEP_SUMMARY
        echo "- Build & Test: ${{ needs.build-and-test.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Docker Build: ${{ needs.build-and-push.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Dev Deploy: ${{ needs.deploy-dev.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
        echo "- E2E Tests: ${{ needs.e2e-tests.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Prod Deploy: ${{ needs.deploy-prod.result == 'success' && 'âœ…' || (needs.deploy-prod.result == 'skipped' && 'â­ï¸') || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY